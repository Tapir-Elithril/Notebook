<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
<div align=center>
    <font size=20 face=黑体>
量子计算理论基础与软件系统<br/><br/> Lab1:Quantum Circuit Simulation
    </font>
    <font size=5 face=楷体>
<br/><br/>
杨亿酬 3230105697<br/>
2025-10-11 - 2025-10-
    </font>
</div>

<div STYLE="page-break-after: always;"></div>

### 1. 根据 `qubit_simulator` 中的源代码分析 `qubit-simulator` 的基本原理、结构及运行流程。
[Answer]  
`Gates`类给出了基本的量子门的实现方式，包括H门，T门，X门，通用U门（参数$\phi,\theta,\lambda$)，控制门与逆门，返回量子门对应的矩阵，下面以控制门为例，详细说明矩阵的构建思路：  
```python
    controlled_gate = np.eye(2**num_qubits, dtype=complex)
    for basis in range(2**num_qubits):
        basis_binary = format(basis, f"0{num_qubits}b")
        if basis_binary[control_qubit] == "1":
            target_state = int(
                basis_binary[:target_qubit]
                + str(1 - int(basis_binary[target_qubit]))
                + basis_binary[target_qubit + 1 :],
                2,
            )
            controlled_gate[basis, basis] = ...
            controlled_gate[basis, target_state] = ...
            controlled_gate[target_state, basis] = ...
            controlled_gate[target_state, target_state] = ... 
    return controlled_gate
```
首先根据输入的比特数构建一个单位矩阵，表示没有任何变换  
遍历每一种可能的量子态（`2**num_qubits`种)，观察该基态的控制比特，如果为0则不变，如果为1则表示需要变换，此时需要改变目标比特的状态  
随后修改对应的2*2子矩阵来表示对目标比特应用了输入的门（张量积）  
具体应用方式如下：
```python
current = int(basis_binary[target_qubit])   
flipped = 1 - current                        

controlled_gate[basis, basis] = gate[current, current]
controlled_gate[basis, target_state] = gate[current, flipped]
controlled_gate[target_state, basis] = gate[flipped, current]  
controlled_gate[target_state, target_state] = gate[flipped, flipped]
```
将控制比特设置为gate的对应值，将受控比特翻转  
具体到CNOT门的例子，给定  
```python
num_qubit = 2
control_qubit = 0
target_qubit = 1
gate = [[0,1],[1,0]] # X门
```
两个量子比特对应四个基态$\ket{00},\ket{01},\ket{10},\ket{11}$  
初始化单位矩阵如下  
```text
[[1, 0, 0, 0],
 [0, 1, 0, 0],
 [0, 0, 1, 0],
 [0, 0, 0, 1]]
```
遍历四种基态，前两种基态控制比特为0，不操作，保持单位矩阵  
$\ket{10}$的控制位为1，将其翻转为$\ket{11}$,对应修改矩阵：  
```python
controlled_gate[2, 2] = gate[0, 0] = 0  # |10⟩ →|10⟩
controlled_gate[2, 3] = gate[0, 1] = 1  # |10⟩ →|11⟩  
controlled_gate[3, 2] = gate[1, 0] = 1  # |11⟩ →|10⟩
controlled_gate[3, 3] = gate[1, 1] = 0  # |11⟩ →|11⟩
```
修改后的矩阵如下：  
```text
[[1, 0, 0, 0],
 [0, 1, 0, 0],
 [0, 0, 0, 1],
 [0, 0, 1, 0]]
```
这个矩阵对应的就是CNOT门（$\ket{11}$执行的矩阵操作与$\ket{10}$相同）    


`QubitSimulator`类给出了运行流程  
成员变量：`num_qubit`表示比特数,`state_vector`表示状态向量，初始化`state_vector[0]=1`对应基态$\ket{00...0}$,`circuit`记录门电路的操作过程，是一个量子门名称，目标比特和控制比特（控制门）构成的元组的列表  
```python
    def _apply_gate(...):
        if control_qubit is not None:
            operator = Gates.create_controlled_gate(
                gate, control_qubit, target_qubit, self.num_qubits
            )
        else:
            operator = np.eye(1)
            for qubit in range(self.num_qubits):
                operator = np.kron( # kronecker product
                    operator,
                    gate if qubit == target_qubit else np.eye(2),
                )
        self.state_vector = operator @ self.state_vector
        self.circuit.append((gate_name, target_qubit, control_qubit))
```
`_apply_gate`函数给出了应用门的方法，如果控制比特不为空，创建一个控制门，否则通过张量积的方式对目标比特应用输入门；随后让每个基态通过矩阵改变状态，最后将应用记录添加到`circuit`中  
`measure`函数模拟量子测量，首先通过波函数系数的平方计算概率，依据该概率生成分布计数并处理误差  

整体运行流程为：  
1.应用`Gates`类函数创建门  
2.对`state_vector`应用门  
3.将应用记录添加到列表`circuit`中  
4.应用`measure`方法模拟测量各状态出现的次数  
5.`plot_wavefunction`绘制对应分布图  
6.`__str__`可以将`circuit`列表转换为字符串便于文本输出  

### 2. 使用 `qubit-simulator` 构造如下图所示的五量子比特 GHZ 电路，并模拟运行，画出结果概率分布直方图。
<img src="./ghz_5.png" alt="图片描述" width="300" style="display: block; margin: 0 auto;">
从左至右逐一应用H门和四个CNOT门，注意上方为控制比特，下方为目标比特  

```python
# test.py
from qubit_simulator import QubitSimulator

if __name__ == "__main__":
    simulator = QubitSimulator(num_qubits=5)
    simulator.h(0)
    simulator.cx(1,0) # target, control
    simulator.cx(2,1)
    simulator.cx(3,2)
    simulator.cx(4,3)

    res = simulator.run(shots=1000)
    print(res)
    print(simulator)
    simulator.plot_wavefunction()
```

![](image.png)
注意到control位均为0，只有H门起了实际作用，这与实际结果是相符的  
图中只有00000与10000实部有值，其余量子态均为0  

### 3. 代码构造了一个量子电路，运行代码，并尝试调整代码中 `n_qubits` 的值，然后观察量子电路模拟的运行时间。绘制量子电路模拟运行时间与量子电路比特数的关系图，并分析 `qubit-simulator` 进行量子电路模拟的复杂度。

```python
def apply_circuit(circuit, n):
    ...

qubit_counts = list(range(2,15 + 1)) # from 2 to 15
execution_times = []

for n_qubits in qubit_counts:
    simulator = QubitSimulator(n_qubits)

    t = time.time()
    apply_circuit(simulator, n_qubits)
    execution_time = time.time() - t
    print(f"n_qubits = {n_qubits}:{execution_time}s")
    execution_times.append(execution_time)
    simulator.run(shots=1000)

plt...
```
从量子比特数2至15逐一尝试构造随机量子电路，计算时间  
（n=16时设备难以运行出结果）  
![](image-1.png)  
实验表明构造量子电路所需要的时间与比特数大致呈指数增长的关系  
注意n=2时的运行时长异常偏高主要来源于python的启动开销  

理论解释：尤其注意`self.state_vector = np.zeros(2**num_qubits, dtype=complex)`，状态向量的数量与输入比特呈$2^n$  
单比特量子门（H门）：$O(2^n)$  
双比特量子门（control-u gate):`_apply_gate`中，`self.state_vector = operator @ self.state_vector`进行$2^n* 2^n$矩阵与$2^n*1$向量的乘法运算，时间复杂度$O(4^n)$  
```python
def apply_circuit(circuit, n):
    circuit.h(n - 1)
    for qubit in range(n - 1): # construct n gates
        circuit.cu(qubit, qubit + 1, random.random() * 3.14,
         random.random() * 3.14, random.random() * 3.14)
```
n次循环总时间复杂度为$O(n\cdot4^n)$,这与实验数据相吻合  
